---
# util_server-role/tasks/pi-hole.yml
- name: Check whether pi-hole is already installed, by checking presence of gravity database
  ansible.builtin.stat:
    path: /etc/pihole/gravity.db
  register: pihole_db

- name: Set a flag that tells us whether pi-hole was already present
  ansible.builtin.set_fact:
    pihole_present: "{{ pihole_db.stat.exists | default(false) }}"

- name: Debug flags and settings
  ansible.builtin.debug:
    msg: "pihole action is {{ pihole_action }}, pihole_present is {{ pihole_present }}"

- name: Irrespective of the pihole_enable_unbound setting, initial config is without unbound
  ansible.builtin.set_fact:
    pihole_enable_unbound_greenlight: false

# pihole_action "reinstall" overrides the check to install
- name: Include tasks to actually (re-)install pihole
  ansible.builtin.import_tasks:
    file: install-pihole.yml
  when: pihole_action == "reinstall" or not pihole_present

# (Re)-write the pihole.toml configuration file according to our settings
- name: Rewrite the settings file in case we made config changes
  ansible.builtin.template:
    src: etc/pihole/pihole.toml.j2
    dest: /etc/pihole/pihole.toml
    mode: "0644"
  notify: Restart pihole-FTL

# Everything is in place, so it should be safe to flush handlers, that may mean samba restart
- name: Flush handlers after (re-)install
  ansible.builtin.meta: flush_handlers

- name: Refresh check whether pi-hole is already installed, by checking presence of gravity database
  ansible.builtin.stat:
    path: /etc/pihole/gravity.db
  register: pihole_db

- name: Refresh the flag that tells us whether pi-hole is now present
  ansible.builtin.set_fact:
    pihole_present: "{{ pihole_db.stat.exists | default(false) }}"

- name: Upgrade pi-hole if it is already installed
  ansible.builtin.command:
    cmd: pihole -up
  environment:
    PIHOLE_SKIP_OS_CHECK: 'true'
  become: true
  register: pihole_update
  when: pihole_present and not pihole_action == "reinstall"
  changed_when: "'Everything is up to date!' not in pihole_update.stdout"

# Check if pihole-FTL is running. If not, we will try to fix it
- name: Check status of pihole-FTL
  ansible.builtin.systemd_service:
    name: pihole-FTL
  register: pihole_ftl_status

- name: Tell user the status of pihole-FTL
  ansible.builtin.debug:
    msg: "FTL is {{ pihole_ftl_status.status.ActiveState }}. Trying corrective action."
  when: pihole_ftl_status.status.ActiveState != "active"

- name: Take corrective action if FTL not running
  ansible.builtin.include_tasks: correct-systemd-piholeFTL.yml
  when: pihole_ftl_status.status.ActiveState != "active"

# Do not mess with the db if there is no db (should not occur at this point in the script)
- name: Import tasks to update the gravity database with adlists, and white- and blacklists
  ansible.builtin.import_tasks:
    file: pihole-listmanage.yml
  when:
    - pihole_action != "local" and pihole_present

# This directory should already be there
- name: Create the dnsmasq config directory if it does not exist yet
  ansible.builtin.file:
    path: /etc/dnsmasq.d
    state: directory
    mode: "0755"

# This is where we tell the DNS service to attach to the target interface
- name: Place the custom configuration into the dnsmasq.d directory
  ansible.builtin.template:
    src: etc/dnsmasq.d/99-pihole.conf.j2
    dest: /etc/dnsmasq.d/99-pihole.conf
    mode: "0644"
  notify: Restart pihole-FTL

# # This is where we apply a wildcard domain resolution
# - name: Place the configuration for wildcard in the dnsmasq.d directory
#   ansible.builtin.template:
#     src: etc/dnsmasq.d/99-pihole-wildcard.conf.j2
#     dest: /etc/dnsmasq.d/99-pihole-wildcard.conf
#     mode: "0644"
#   when: pihole_localdns_authoritativedomain != "authoritativedomain"

# In pi-hole web interface, this is known as the 'local DNS'
# As this may contain sensitive info, the src is the private repository
# Include yours in pihole_localdns_newlist or in the secrets include

- name: Get currently configured local DNS entries in Pi-hole
  ansible.builtin.uri:
    url: "http://{{ ansible_host }}/api/config/dns/hosts"
    method: GET
    return_content: true
    status_code: 200
  register: pihole_localdns

- name: Bulk get rid of current local DNS entries in Pi-hole. Also set authoritative domain to 'local' to avoid issues.
  ansible.builtin.uri:
    url: "http://{{ ansible_host }}/api/config"
    method: PATCH
    body_format: json
    body: |
        {
           "config": {
             "dns": {
               "hosts": [],
               "domain": "local"
               }
             }
         }
  when: pihole_localdns.json is defined and (pihole_localdns.json | length) > 0

- name: Bulk set new domains. Set authoritative domain to {{ pihole_local_domain }}
  ansible.builtin.uri:
    url: "http://{{ ansible_host }}/api/config"
    method: PATCH
    body_format: json
    body: |
       {
          "config": {
            "dns": {
              "domain": "{{ pihole_local_domain }}",
              "hosts": {{ pihole_localdns_newlist | to_json }}
              }
            }
        }
  register: pihole_dnsdomain
  retries: 3
  delay: 5
  when: pihole_localdns_newlist is defined and (pihole_localdns_newlist | length) > 0

- name: Report out to user
  ansible.builtin.debug:
    msg: "Local DNS entries added: {{ pihole_localdns_newlist | length }}"
  when: pihole_localdns_newlist is defined and (pihole_localdns_newlist | length) > 0
